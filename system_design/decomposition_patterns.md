Смотать монолит в микросервисы — это не один «правильный» способ, а набор паттернов декомпозиции. Их удобно делить на бизнесовые (как режем домен) и технические (как режем по технологиям и инфраструктуре). Ниже дам карту, а потом можно будет привязать к твоим кейсам.

1. Бизнесовые паттерны декомпозиции
1.1. По бизнес-возможностям (Business Capability)

Идея: режем систему по крупным блокам «что компания умеет делать», а не по сущностям БД.

Примеры capabilities интернет-магазина:

Каталог и поиск товаров

Ценообразование и акции

Корзина и оформление заказа

Оплата

Логистика и доставка

Личный кабинет и лояльность

Плюсы:

Прямо отражает оргструктуру и зону ответственности команд.

Каждый сервис «владеет» своим кусочком ценности и метриками.

Проще искать владельца проблемы: «упало оформление заказа» — значит, команда Checkout.

Минусы:

Требует нормального domain/business analysis, иначе нарежешь по интуиции, а потом будет резать заново.

На старте часто всё переплетено: один модуль «за всё хорошее» (заказ+оплата+акции).

Когда использовать:

Когда уже есть продукт, понятные бизнес-процессы и команды вокруг них.

Когда от архитектуры требуют «понятных границ ответственности» для оргструктуры.

1.2. По границам контекстов (Domain-driven Design, Bounded Context)

Идея: смотрим на домен через DDD: внутри контекста у нас своя модель, язык, инварианты; между контекстами — интеграция через события/контракты.

Примеры bounded contexts для того же магазина:

Sales: корзина, заказы, скидки с точки зрения продажи.

Billing: оплата, счета, возвраты денег.

Shipping: доставка, трекинг посылок.

CRM: пользователи, сегменты, коммуникации.

Плюсы:

Убирает раздутые бог-объекты вроде User, Order, которые используются везде.

Позволяет иметь разные представления одной сущности в разных контекстах (Order в Sales vs Order в Billing).

Минусы:

Требует сильного доменного анализа и участия бизнеса.

Легко впасть в теорию и нарисовать идеальный DDD-зоопарк, который никто не успеет реализовать.

Когда использовать:

Когда нужен долгоживущий архитектурный фундамент.

Когда много конфликтующих требований к одним и тем же сущностям.

1.3. По потокам (slices) пользовательских сценариев

Идея: берем end-to-end flow и выделяем сервисы вокруг конкретных юзерских сценариев:

Registration & Onboarding service

Checkout flow service

Subscription management service

Иногда это вариация на тему Business Capability, но:

Business capability = «что мы умеем» (продуктовая функция),

Flow-based = «как пользователь проходит путь» (сценарий).

Плюсы:

Быстро даёт выигрыш в автономности: команда делает один конкретный сценарий от UI до БД/интеграций.

Хорошо ложится на BFF / vertical slice подход.

Минусы:

Есть риск дублирования логики между разными сценариями.

Нужна дисциплина, чтобы не превратить каждый новый сценарий в новый микросервис.

Когда использовать:

Когда задача — быстро отпилить наиболее критические пути (например, оформление заказа) и сделать их независимыми по изменениям и релизам.

1.4. По линиям бизнеса / продуктам

Идея: если у вас несколько продуктовых линий/брендов, можно резать так:

«Онлайн-школа для B2C»

«Платформа для B2B-партнёров»

«Внутренний админ/бэк-офис»

Каждая линия получает свои микросервисы, даже если домен похож.

Плюсы:

Максимальная независимость по roadmap’ам и приоритизации.

Проще масштабировать компании «по продуктам».

Минусы:

Много дублирования логики, справочников, интеграций.

Нужно потом решать кросс-cutting вещи: платежи, авторизация, профили.

Когда использовать:

Когда у компании несколько полу-независимых бизнесов с разными рынками/клиентами.

2. Технические паттерны декомпозиции

Тут мы больше смотрим не на бизнес, а на технологические швы: БД, интеграции, нагрузку, типы операций.

2.1. По данным / границам владения БД (Database per Service)

Идея: выделяем сервисы вокруг блоков данных, которыми они владеют:

Users DB → User/Identity Service

Orders DB → Order Service

Payments DB → Payment Service

Плюсы:

За каждый кусок данных отвечает один сервис → меньше конфликтов, проще эволюция схемы.

Можно выбирать подходящую технологию: Postgres для транзакций, ClickHouse для аналитики.

Минусы:

Жёсткие data consistency trade-offs (eventual consistency, saga, outbox и т.д.).

Сложнее писать «толстые» отчёты: данные раскиданы.

Когда использовать:

Когда монолит уже страдает от схемы БД (огромное количество таблиц, блокировки, миграции, зависимость 1000 модулей от одной схемы).

2.2. По слоям (Layered decomposition) — как антипаттерн в чистом виде

Классический анти-паттерн:

Service A — только UI/API

Service B — только business logic

Service C — только DAO/DB

Формально мы вроде бы «нарезали» монолит, но:

Истинной автономности нет — всё связано жёстко.

Независимо деплоить и масштабировать нельзя (или бессмысленно).

По сути, получили распределённый монолит.

Где это всё-таки применимо:

Иногда выделяют только внешние «edge-сервисы» (API Gateway, BFF, Auth-Proxy) отдельно от core-логики.

Но core лучше делить по домену/контекстам, а не по устоям слоёв.

2.3. По особенностям нагрузки

Идея: выделяем сервисы там, где сильно различаются характер нагрузки и NFR’ы:

Сервис очередей и нотификаций (много I/O, нестрогая латентность).

Отдельный сервис генерации отчётов и аналитики (тяжёлые запросы, batch-job’ы).

Отдельный real-time сервис для WebSocket/stream’ов (жёсткие требования к latency).

Плюсы:

Можно отдельно масштабировать горячие куски.

Можно использовать разные технологии (in-memory store, OLAP, stream-processing).

Минусы:

Если резать только по нагрузке, рискуешь получить доменно-размазанные сервисы.

Когда использовать:

Как второй слой декомпозиции поверх бизнес-паттернов: сперва режем по домену, потом в отдельном домене выделяем тяжёлые части.

2.4. По интеграциям / внешним системам

Идея: выделяем адаптеры/антенны ко внешним системам в отдельные сервисы:

Payment-gateway service (аггрегирует несколько PSP).

CRM-integration service.

1C/ERP-integration service и т.п.

Плюсы:

Внешняя интеграция — один из главных источников нестабильности; её удобно изолировать.

Можно менять внешнего провайдера, не трогая core-домен.

Минусы:

Опять риск сделать «слишком техничные» сервисы, которые ничего не знают о домене, и логика растечётся по куче мест.

Когда использовать:

Всегда, когда внешний контур существенно влияет на стабильность и скорость изменений.

2.5. По технологическому стеку / языкам

Идея: часть функционала переписывается на другом языке/стеке и выделяется в сервис:

МL-модель в Python → отдельный scoring-service.

Отдельный сервис на Go под heavy-I/O.

Плюсы:

Можно использовать оптимальный стек под конкретную задачу.

Позволяет эволюционно переписывать painful-участки монолита.

Минусы:

Языковая/технологическая зоопарковость, сложнее поддерживать.

Команде нужны скиллы под разные стеки.

Когда использовать:

Локально, для специфических задач (ML, high-load I/O, streaming), а не как главный принцип нарезки.

3. Как их сочетать на практике

На практике редко используют один паттерн «в чистом виде». Часто получается примерно так:

Сверху вниз — бизнесовая декомпозиция:

Определили bounded contexts / business capabilities.

На их основе определили основные микросервисы (или хотя бы модули в монолите на первом шаге).

Снизу вверх — техническая декомпозиция:

Для каждого контекста смотрим:

Какие данные он собственно хранит? → отдельная БД/схема.

Какие куски сильно отличаются по нагрузке? → выносим в самостоятельные worker / reporting / streaming сервисы.

Какие внешние системы тут критичны? → делаем интеграционные сервисы/адаптеры.

Эволюционный подход:

Сначала делаем модульную архитектуру монолита (modular monolith): чёткие модули, запрет прямых cross-import, ограниченная общая БД.

Потом выносим самый болезненный модуль наружу:

выделяем его схемы/таблицы;

делаем API/события вместо прямых вызовов/SQL;

ставим анти-corruption layer (ACL), если надо.

4. Несколько антипаттернов и ловушек

Декомпозиция только по таблицам БД:

«У нас таблица orders — давайте сделаем OrderService, таблица discounts — DiscountService и т.д.»

Если не учитывать домен, получишь mess из микросервисов, которые единичной ценности не несут.

Сервисы по «ролям»:

AdminService, ClientService, ManagerService — это плохие кандидаты. Роли — это почти всегда cross-cutting, лучше отдавать это на уровень ACL/permissions, а не архитектурные границы.

Всё сразу в микросервисы:

Без модульного монолита как переходного этапа почти гарантированно получаешь распределённый монолит и рост операционной сложности ×10.

Игнорирование оргструктуры:

Архитектуру надо синхронизировать с командами (Conway’s Law). Если нарезка сервисов не совпадает с нарезкой команд — будет постоянная боль и конфликты.

5. Как про это рассказывать «по-лидерски» на собесе

Если тебе нужно объяснять это, как тех/тимлиду / архитектору, структура ответа может быть такой:

Мы смотрим на домен:

«Сначала я выделяю бизнес-возможности и bounded contexts: где у нас свои инварианты, свой язык, свой ownership данных».

Мы учитываем нетфункциональные требования:

«Для каждого контекста смотрю на профиль нагрузки, SLA, требования к масштабированию — это задаёт технические швы: отдельные сервисы под real-time, отчёты, интеграции».

Мы двигаемся эволюционно:

«Инженерно это чаще всего модульный монолит → выделение критичных модулей в микросервисы, с отдельной БД и асинхронной связкой».

Мы избегаем типичных ловушек:

«Не режем только по слоям, таблицам или ролям; не плодим зоопарк микросервисов без понятной бизнес-ценности».